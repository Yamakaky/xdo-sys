/* automatically generated by rust-bindgen 0.59.1 */

pub type __useconds_t = ::std::os::raw::c_uint;
pub type XID = ::std::os::raw::c_ulong;
pub type Atom = ::std::os::raw::c_ulong;
pub type VisualID = ::std::os::raw::c_ulong;
pub type Window = XID;
pub type Colormap = XID;
pub type KeySym = XID;
pub type KeyCode = ::std::os::raw::c_uchar;
pub type wchar_t = ::std::os::raw::c_int;
pub type XPointer = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XExtData {
    pub number: ::std::os::raw::c_int,
    pub next: *mut _XExtData,
    pub free_private: ::std::option::Option<
        unsafe extern "C" fn(extension: *mut _XExtData) -> ::std::os::raw::c_int,
    >,
    pub private_data: XPointer,
}
#[test]
fn bindgen_test_layout__XExtData() {
    assert_eq!(
        ::std::mem::size_of::<_XExtData>(),
        32usize,
        concat!("Size of: ", stringify!(_XExtData))
    );
    assert_eq!(
        ::std::mem::align_of::<_XExtData>(),
        8usize,
        concat!("Alignment of ", stringify!(_XExtData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).free_private as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(free_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XExtData>())).private_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(private_data)
        )
    );
}
pub type XExtData = _XExtData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XGC {
    _unused: [u8; 0],
}
pub type GC = *mut _XGC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Visual {
    pub ext_data: *mut XExtData,
    pub visualid: VisualID,
    pub class: ::std::os::raw::c_int,
    pub red_mask: ::std::os::raw::c_ulong,
    pub green_mask: ::std::os::raw::c_ulong,
    pub blue_mask: ::std::os::raw::c_ulong,
    pub bits_per_rgb: ::std::os::raw::c_int,
    pub map_entries: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Visual() {
    assert_eq!(
        ::std::mem::size_of::<Visual>(),
        56usize,
        concat!("Size of: ", stringify!(Visual))
    );
    assert_eq!(
        ::std::mem::align_of::<Visual>(),
        8usize,
        concat!("Alignment of ", stringify!(Visual))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).visualid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(visualid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).class as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).red_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).green_mask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).blue_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).bits_per_rgb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(bits_per_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Visual>())).map_entries as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(map_entries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Depth {
    pub depth: ::std::os::raw::c_int,
    pub nvisuals: ::std::os::raw::c_int,
    pub visuals: *mut Visual,
}
#[test]
fn bindgen_test_layout_Depth() {
    assert_eq!(
        ::std::mem::size_of::<Depth>(),
        16usize,
        concat!("Size of: ", stringify!(Depth))
    );
    assert_eq!(
        ::std::mem::align_of::<Depth>(),
        8usize,
        concat!("Alignment of ", stringify!(Depth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Depth>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Depth>())).nvisuals as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(nvisuals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Depth>())).visuals as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(visuals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XDisplay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Screen {
    pub ext_data: *mut XExtData,
    pub display: *mut _XDisplay,
    pub root: Window,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mwidth: ::std::os::raw::c_int,
    pub mheight: ::std::os::raw::c_int,
    pub ndepths: ::std::os::raw::c_int,
    pub depths: *mut Depth,
    pub root_depth: ::std::os::raw::c_int,
    pub root_visual: *mut Visual,
    pub default_gc: GC,
    pub cmap: Colormap,
    pub white_pixel: ::std::os::raw::c_ulong,
    pub black_pixel: ::std::os::raw::c_ulong,
    pub max_maps: ::std::os::raw::c_int,
    pub min_maps: ::std::os::raw::c_int,
    pub backing_store: ::std::os::raw::c_int,
    pub save_unders: ::std::os::raw::c_int,
    pub root_input_mask: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_Screen() {
    assert_eq!(
        ::std::mem::size_of::<Screen>(),
        128usize,
        concat!("Size of: ", stringify!(Screen))
    );
    assert_eq!(
        ::std::mem::align_of::<Screen>(),
        8usize,
        concat!("Alignment of ", stringify!(Screen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).mwidth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).mheight as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).ndepths as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ndepths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).depths as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(depths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root_depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root_visual as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).default_gc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(default_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).cmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).white_pixel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).black_pixel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).max_maps as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(max_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).min_maps as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(min_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).backing_store as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).save_unders as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Screen>())).root_input_mask as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_input_mask)
        )
    );
}
pub type Display = _XDisplay;
pub type useconds_t = __useconds_t;
#[doc = " @internal"]
#[doc = " Map character to whatever information we need to be able to send"]
#[doc = " this key (keycode, modifiers, group, etc)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charcodemap {
    pub key: wchar_t,
    #[doc = " the letter for this key, like 'a'"]
    pub code: KeyCode,
    #[doc = " the keycode that this key is on"]
    pub symbol: KeySym,
    #[doc = " the symbol representing this key"]
    pub group: ::std::os::raw::c_int,
    #[doc = " the keyboard group that has this key in it"]
    pub modmask: ::std::os::raw::c_int,
    #[doc = " the modifiers to apply when sending this key */"]
    #[doc = " exist in the current keymap, this will be set to 1."]
    pub needs_binding: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_charcodemap() {
    assert_eq!(
        ::std::mem::size_of::<charcodemap>(),
        32usize,
        concat!("Size of: ", stringify!(charcodemap))
    );
    assert_eq!(
        ::std::mem::align_of::<charcodemap>(),
        8usize,
        concat!("Alignment of ", stringify!(charcodemap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charcodemap>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(charcodemap),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charcodemap>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(charcodemap),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charcodemap>())).symbol as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(charcodemap),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charcodemap>())).group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(charcodemap),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charcodemap>())).modmask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(charcodemap),
            "::",
            stringify!(modmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charcodemap>())).needs_binding as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(charcodemap),
            "::",
            stringify!(needs_binding)
        )
    );
}
#[doc = " @internal"]
#[doc = " Map character to whatever information we need to be able to send"]
#[doc = " this key (keycode, modifiers, group, etc)"]
pub type charcodemap_t = charcodemap;
#[doc = " The main context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdo {
    #[doc = " The Display for Xlib"]
    pub xdpy: *mut Display,
    #[doc = " The display name, if any. NULL if not specified."]
    pub display_name: *mut ::std::os::raw::c_char,
    #[doc = " @internal Array of known keys/characters"]
    pub charcodes: *mut charcodemap_t,
    #[doc = " @internal Length of charcodes array"]
    pub charcodes_len: ::std::os::raw::c_int,
    #[doc = " @internal highest keycode value"]
    pub keycode_high: ::std::os::raw::c_int,
    #[doc = " @internal lowest keycode value"]
    pub keycode_low: ::std::os::raw::c_int,
    #[doc = " @internal number of keysyms per keycode"]
    pub keysyms_per_keycode: ::std::os::raw::c_int,
    #[doc = " Should we close the display when calling xdo_free?"]
    pub close_display_when_freed: ::std::os::raw::c_int,
    #[doc = " Be extra quiet? (omits some error/message output)"]
    pub quiet: ::std::os::raw::c_int,
    #[doc = " Enable debug output?"]
    pub debug: ::std::os::raw::c_int,
    #[doc = " Feature flags, such as XDO_FEATURE_XTEST, etc..."]
    pub features_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xdo() {
    assert_eq!(
        ::std::mem::size_of::<xdo>(),
        56usize,
        concat!("Size of: ", stringify!(xdo))
    );
    assert_eq!(
        ::std::mem::align_of::<xdo>(),
        8usize,
        concat!("Alignment of ", stringify!(xdo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).xdpy as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(xdo), "::", stringify!(xdpy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).display_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).charcodes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(charcodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).charcodes_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(charcodes_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).keycode_high as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(keycode_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).keycode_low as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(keycode_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).keysyms_per_keycode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).close_display_when_freed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(close_display_when_freed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).quiet as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).debug as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo>())).features_mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo),
            "::",
            stringify!(features_mask)
        )
    );
}
#[doc = " The main context."]
pub type xdo_t = xdo;
#[doc = " The window search query structure."]
#[doc = ""]
#[doc = " @see xdo_search_windows"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdo_search {
    pub title: *const ::std::os::raw::c_char,
    #[doc = " pattern to test against a window title"]
    pub winclass: *const ::std::os::raw::c_char,
    #[doc = " pattern to test against a window class"]
    pub winclassname: *const ::std::os::raw::c_char,
    #[doc = " pattern to test against a window class"]
    pub winname: *const ::std::os::raw::c_char,
    #[doc = " pattern to test against a window name"]
    pub winrole: *const ::std::os::raw::c_char,
    #[doc = " pattern to test against a window role"]
    pub pid: ::std::os::raw::c_int,
    #[doc = " window pid (From window atom _NET_WM_PID)"]
    pub max_depth: ::std::os::raw::c_long,
    #[doc = " depth of search. 1 means only toplevel windows"]
    pub only_visible: ::std::os::raw::c_int,
    #[doc = " boolean; set true to search only visible windows"]
    pub screen: ::std::os::raw::c_int,
    pub require: xdo_search__bindgen_ty_1,
    #[doc = " bitmask of things you are searching for, such as SEARCH_NAME, etc."]
    #[doc = " @see SEARCH_NAME, SEARCH_CLASS, SEARCH_PID, SEARCH_CLASSNAME, etc"]
    pub searchmask: ::std::os::raw::c_uint,
    #[doc = " What desktop to search, if any. If none given, search all screens."]
    pub desktop: ::std::os::raw::c_long,
    #[doc = " How many results to return? If 0, return all."]
    pub limit: ::std::os::raw::c_uint,
}
pub const xdo_search_SEARCH_ANY: ::std::os::raw::c_uint = 0;
pub const xdo_search_SEARCH_ALL: ::std::os::raw::c_uint = 1;
#[doc = " Should the tests be 'and' or 'or' ? If 'and', any failure will skip the"]
#[doc = " window. If 'or', any success will keep the window in search results."]
pub type xdo_search__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_xdo_search() {
    assert_eq!(
        ::std::mem::size_of::<xdo_search>(),
        88usize,
        concat!("Size of: ", stringify!(xdo_search))
    );
    assert_eq!(
        ::std::mem::align_of::<xdo_search>(),
        8usize,
        concat!("Alignment of ", stringify!(xdo_search))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).winclass as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(winclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).winclassname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(winclassname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).winname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(winname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).winrole as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(winrole)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).pid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).max_depth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(max_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).only_visible as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(only_visible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).screen as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).require as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(require)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).searchmask as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(searchmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).desktop as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(desktop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xdo_search>())).limit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xdo_search),
            "::",
            stringify!(limit)
        )
    );
}
#[doc = " The window search query structure."]
#[doc = ""]
#[doc = " @see xdo_search_windows"]
pub type xdo_search_t = xdo_search;
extern "C" {
    #[doc = " Create a new xdo_t instance."]
    #[doc = ""]
    #[doc = " @param display the string display name, such as \":0\". If null, uses the"]
    #[doc = " environment variable DISPLAY just like XOpenDisplay(NULL)."]
    #[doc = ""]
    #[doc = " @return Pointer to a new xdo_t or NULL on failure"]
    pub fn xdo_new(display: *const ::std::os::raw::c_char) -> *mut xdo_t;
}
extern "C" {
    #[doc = " Create a new xdo_t instance with an existing X11 Display instance."]
    #[doc = ""]
    #[doc = " @param xdpy the Display pointer given by a previous XOpenDisplay()"]
    #[doc = " @param display the string display name"]
    #[doc = " @param close_display_when_freed If true, we will close the display when"]
    #[doc = " xdo_free is called. Otherwise, we leave it open."]
    pub fn xdo_new_with_opened_display(
        xdpy: *mut Display,
        display: *const ::std::os::raw::c_char,
        close_display_when_freed: ::std::os::raw::c_int,
    ) -> *mut xdo_t;
}
extern "C" {
    #[doc = " Return a string representing the version of this library"]
    pub fn xdo_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Free and destroy an xdo_t instance."]
    #[doc = ""]
    #[doc = " If close_display_when_freed is set, then we will also close the Display."]
    pub fn xdo_free(xdo: *mut xdo_t);
}
extern "C" {
    #[doc = " Move the mouse to a specific location."]
    #[doc = ""]
    #[doc = " @param x the target X coordinate on the screen in pixels."]
    #[doc = " @param y the target Y coordinate on the screen in pixels."]
    #[doc = " @param screen the screen (number) you want to move on."]
    pub fn xdo_move_mouse(
        xdo: *const xdo_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        screen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move the mouse to a specific location relative to the top-left corner"]
    #[doc = " of a window."]
    #[doc = ""]
    #[doc = " @param x the target X coordinate on the screen in pixels."]
    #[doc = " @param y the target Y coordinate on the screen in pixels."]
    pub fn xdo_move_mouse_relative_to_window(
        xdo: *const xdo_t,
        window: Window,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move the mouse relative to it's current position."]
    #[doc = ""]
    #[doc = " @param x the distance in pixels to move on the X axis."]
    #[doc = " @param y the distance in pixels to move on the Y axis."]
    pub fn xdo_move_mouse_relative(
        xdo: *const xdo_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a mouse press (aka mouse down) for a given button at the current mouse"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " @param window The window you want to send the event to or CURRENTWINDOW"]
    #[doc = " @param button The mouse button. Generally, 1 is left, 2 is middle, 3 is"]
    #[doc = "    right, 4 is wheel up, 5 is wheel down."]
    pub fn xdo_mouse_down(
        xdo: *const xdo_t,
        window: Window,
        button: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a mouse release (aka mouse up) for a given button at the current mouse"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " @param window The window you want to send the event to or CURRENTWINDOW"]
    #[doc = " @param button The mouse button. Generally, 1 is left, 2 is middle, 3 is"]
    #[doc = "    right, 4 is wheel up, 5 is wheel down."]
    pub fn xdo_mouse_up(
        xdo: *const xdo_t,
        window: Window,
        button: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current mouse location (coordinates and screen number)."]
    #[doc = ""]
    #[doc = " @param x integer pointer where the X coordinate will be stored"]
    #[doc = " @param y integer pointer where the Y coordinate will be stored"]
    #[doc = " @param screen_num integer pointer where the screen number will be stored"]
    pub fn xdo_get_mouse_location(
        xdo: *const xdo_t,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
        screen_num: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the window the mouse is currently over"]
    #[doc = ""]
    #[doc = " @param window_ret Window pointer where the window will be stored."]
    pub fn xdo_get_window_at_mouse(
        xdo: *const xdo_t,
        window_ret: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get all mouse location-related data."]
    #[doc = ""]
    #[doc = " If null is passed for any parameter, we simply do not store it."]
    #[doc = " Useful if you only want the 'y' coordinate, for example."]
    #[doc = ""]
    #[doc = " @param x integer pointer where the X coordinate will be stored"]
    #[doc = " @param y integer pointer where the Y coordinate will be stored"]
    #[doc = " @param screen_num integer pointer where the screen number will be stored"]
    #[doc = " @param window Window pointer where the window/client the mouse is over"]
    #[doc = "   will be stored."]
    pub fn xdo_get_mouse_location2(
        xdo: *const xdo_t,
        x_ret: *mut ::std::os::raw::c_int,
        y_ret: *mut ::std::os::raw::c_int,
        screen_num_ret: *mut ::std::os::raw::c_int,
        window_ret: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for the mouse to move from a location. This function will block"]
    #[doc = " until the condition has been satisfied."]
    #[doc = ""]
    #[doc = " @param origin_x the X position you expect the mouse to move from"]
    #[doc = " @param origin_y the Y position you expect the mouse to move from"]
    pub fn xdo_wait_for_mouse_move_from(
        xdo: *const xdo_t,
        origin_x: ::std::os::raw::c_int,
        origin_y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for the mouse to move to a location. This function will block"]
    #[doc = " until the condition has been satisfied."]
    #[doc = ""]
    #[doc = " @param dest_x the X position you expect the mouse to move to"]
    #[doc = " @param dest_y the Y position you expect the mouse to move to"]
    pub fn xdo_wait_for_mouse_move_to(
        xdo: *const xdo_t,
        dest_x: ::std::os::raw::c_int,
        dest_y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a click for a specific mouse button at the current mouse location."]
    #[doc = ""]
    #[doc = " @param window The window you want to send the event to or CURRENTWINDOW"]
    #[doc = " @param button The mouse button. Generally, 1 is left, 2 is middle, 3 is"]
    #[doc = "    right, 4 is wheel up, 5 is wheel down."]
    pub fn xdo_click_window(
        xdo: *const xdo_t,
        window: Window,
        button: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a one or more clicks for a specific mouse button at the current mouse"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " @param window The window you want to send the event to or CURRENTWINDOW"]
    #[doc = " @param button The mouse button. Generally, 1 is left, 2 is middle, 3 is"]
    #[doc = "    right, 4 is wheel up, 5 is wheel down."]
    pub fn xdo_click_window_multiple(
        xdo: *const xdo_t,
        window: Window,
        button: ::std::os::raw::c_int,
        repeat: ::std::os::raw::c_int,
        delay: useconds_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Type a string to the specified window."]
    #[doc = ""]
    #[doc = " If you want to send a specific key or key sequence, such as \"alt+l\", you"]
    #[doc = " want instead xdo_send_keysequence_window(...)."]
    #[doc = ""]
    #[doc = " @param window The window you want to send keystrokes to or CURRENTWINDOW"]
    #[doc = " @param string The string to type, like \"Hello world!\""]
    #[doc = " @param delay The delay between keystrokes in microseconds. 12000 is a decent"]
    #[doc = "    choice if you don't have other plans."]
    pub fn xdo_enter_text_window(
        xdo: *const xdo_t,
        window: Window,
        string: *const ::std::os::raw::c_char,
        delay: useconds_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a keysequence to the specified window."]
    #[doc = ""]
    #[doc = " This allows you to send keysequences by symbol name. Any combination"]
    #[doc = " of X11 KeySym names separated by '+' are valid. Single KeySym names"]
    #[doc = " are valid, too."]
    #[doc = ""]
    #[doc = " Examples:"]
    #[doc = "   \"l\""]
    #[doc = "   \"semicolon\""]
    #[doc = "   \"alt+Return\""]
    #[doc = "   \"Alt_L+Tab\""]
    #[doc = ""]
    #[doc = " If you want to type a string, such as \"Hello world.\" you want to instead"]
    #[doc = " use xdo_enter_text_window."]
    #[doc = ""]
    #[doc = " @param window The window you want to send the keysequence to or"]
    #[doc = "   CURRENTWINDOW"]
    #[doc = " @param keysequence The string keysequence to send."]
    #[doc = " @param delay The delay between keystrokes in microseconds."]
    pub fn xdo_send_keysequence_window(
        xdo: *const xdo_t,
        window: Window,
        keysequence: *const ::std::os::raw::c_char,
        delay: useconds_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send key release (up) events for the given key sequence."]
    #[doc = ""]
    #[doc = " @see xdo_send_keysequence_window"]
    pub fn xdo_send_keysequence_window_up(
        xdo: *const xdo_t,
        window: Window,
        keysequence: *const ::std::os::raw::c_char,
        delay: useconds_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send key press (down) events for the given key sequence."]
    #[doc = ""]
    #[doc = " @see xdo_send_keysequence_window"]
    pub fn xdo_send_keysequence_window_down(
        xdo: *const xdo_t,
        window: Window,
        keysequence: *const ::std::os::raw::c_char,
        delay: useconds_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a series of keystrokes."]
    #[doc = ""]
    #[doc = " @param window The window to send events to or CURRENTWINDOW"]
    #[doc = " @param keys The array of charcodemap_t entities to send."]
    #[doc = " @param nkeys The length of the keys parameter"]
    #[doc = " @param pressed 1 for key press, 0 for key release."]
    #[doc = " @param modifier Pointer to integer to record the modifiers activated by"]
    #[doc = "   the keys being pressed. If NULL, we don't save the modifiers."]
    #[doc = " @param delay The delay between keystrokes in microseconds."]
    pub fn xdo_send_keysequence_window_list_do(
        xdo: *const xdo_t,
        window: Window,
        keys: *mut charcodemap_t,
        nkeys: ::std::os::raw::c_int,
        pressed: ::std::os::raw::c_int,
        modifier: *mut ::std::os::raw::c_int,
        delay: useconds_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for a window to have a specific map state."]
    #[doc = ""]
    #[doc = " State possibilities:"]
    #[doc = "   IsUnmapped - window is not displayed."]
    #[doc = "   IsViewable - window is mapped and shown (though may be clipped by windows"]
    #[doc = "     on top of it)"]
    #[doc = "   IsUnviewable - window is mapped but a parent window is unmapped."]
    #[doc = ""]
    #[doc = " @param wid the window you want to wait for."]
    #[doc = " @param map_state the state to wait for."]
    pub fn xdo_wait_for_window_map_state(
        xdo: *const xdo_t,
        wid: Window,
        map_state: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xdo_wait_for_window_size(
        xdo: *const xdo_t,
        window: Window,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        to_or_from: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move a window to a specific location."]
    #[doc = ""]
    #[doc = " The top left corner of the window will be moved to the x,y coordinate."]
    #[doc = ""]
    #[doc = " @param wid the window to move"]
    #[doc = " @param x the X coordinate to move to."]
    #[doc = " @param y the Y coordinate to move to."]
    pub fn xdo_move_window(
        xdo: *const xdo_t,
        wid: Window,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply a window's sizing hints (if any) to a given width and height."]
    #[doc = ""]
    #[doc = " This function wraps XGetWMNormalHints() and applies any"]
    #[doc = " resize increment and base size to your given width and height values."]
    #[doc = ""]
    #[doc = " @param window the window to use"]
    #[doc = " @param width the unit width you want to translate"]
    #[doc = " @param height the unit height you want to translate"]
    #[doc = " @param width_ret the return location of the translated width"]
    #[doc = " @param height_ret the return location of the translated height"]
    pub fn xdo_translate_window_with_sizehint(
        xdo: *const xdo_t,
        window: Window,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        width_ret: *mut ::std::os::raw::c_uint,
        height_ret: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the window size."]
    #[doc = ""]
    #[doc = " @param wid the window to resize"]
    #[doc = " @param w the new desired width"]
    #[doc = " @param h the new desired height"]
    #[doc = " @param flags if 0, use pixels for units. If SIZE_USEHINTS, then"]
    #[doc = "   the units will be relative to the window size hints."]
    pub fn xdo_set_window_size(
        xdo: *const xdo_t,
        wid: Window,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change a window property."]
    #[doc = ""]
    #[doc = " Example properties you can change are WM_NAME, WM_ICON_NAME, etc."]
    #[doc = ""]
    #[doc = " @param wid The window to change a property of."]
    #[doc = " @param property the string name of the property."]
    #[doc = " @param value the string value of the property."]
    pub fn xdo_set_window_property(
        xdo: *const xdo_t,
        wid: Window,
        property: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the window's classname and or class."]
    #[doc = ""]
    #[doc = " @param name The new class name. If NULL, no change."]
    #[doc = " @param _class The new class. If NULL, no change."]
    pub fn xdo_set_window_class(
        xdo: *const xdo_t,
        wid: Window,
        name: *const ::std::os::raw::c_char,
        _class: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the urgency hint for a window."]
    pub fn xdo_set_window_urgency(
        xdo: *const xdo_t,
        wid: Window,
        urgency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the override_redirect value for a window. This generally means"]
    #[doc = " whether or not a window manager will manage this window."]
    #[doc = ""]
    #[doc = " If you set it to 1, the window manager will usually not draw borders on the"]
    #[doc = " window, etc. If you set it to 0, the window manager will see it like a"]
    #[doc = " normal application window."]
    #[doc = ""]
    pub fn xdo_set_window_override_redirect(
        xdo: *const xdo_t,
        wid: Window,
        override_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Focus a window."]
    #[doc = ""]
    #[doc = " @see xdo_activate_window"]
    #[doc = " @param wid the window to focus."]
    pub fn xdo_focus_window(xdo: *const xdo_t, wid: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Raise a window to the top of the window stack. This is also sometimes"]
    #[doc = " termed as bringing the window forward."]
    #[doc = ""]
    #[doc = " @param wid The window to raise."]
    pub fn xdo_raise_window(xdo: *const xdo_t, wid: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the window currently having focus."]
    #[doc = ""]
    #[doc = " @param window_ret Pointer to a window where the currently-focused window"]
    #[doc = "   will be stored."]
    pub fn xdo_get_focused_window(
        xdo: *const xdo_t,
        window_ret: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for a window to have or lose focus."]
    #[doc = ""]
    #[doc = " @param window The window to wait on"]
    #[doc = " @param want_focus If 1, wait for focus. If 0, wait for loss of focus."]
    pub fn xdo_wait_for_window_focus(
        xdo: *const xdo_t,
        window: Window,
        want_focus: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the PID owning a window. Not all applications support this."]
    #[doc = " It looks at the _NET_WM_PID property of the window."]
    #[doc = ""]
    #[doc = " @param window the window to query."]
    #[doc = " @return the process id or 0 if no pid found."]
    pub fn xdo_get_pid_window(xdo: *const xdo_t, window: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like xdo_get_focused_window, but return the first ancestor-or-self window *"]
    #[doc = " having a property of WM_CLASS. This allows you to get the \"real\" or"]
    #[doc = " top-level-ish window having focus rather than something you may not expect"]
    #[doc = " to be the window having focused."]
    #[doc = ""]
    #[doc = " @param window_ret Pointer to a window where the currently-focused window"]
    #[doc = "   will be stored."]
    pub fn xdo_get_focused_window_sane(
        xdo: *const xdo_t,
        window_ret: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Activate a window. This is generally a better choice than xdo_focus_window"]
    #[doc = " for a variety of reasons, but it requires window manager support:"]
    #[doc = "   - If the window is on another desktop, that desktop is switched to."]
    #[doc = "   - It moves the window forward rather than simply focusing it"]
    #[doc = ""]
    #[doc = " Requires your window manager to support this."]
    #[doc = " Uses _NET_ACTIVE_WINDOW from the EWMH spec."]
    #[doc = ""]
    #[doc = " @param wid the window to activate"]
    pub fn xdo_activate_window(xdo: *const xdo_t, wid: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for a window to be active or not active."]
    #[doc = ""]
    #[doc = " Requires your window manager to support this."]
    #[doc = " Uses _NET_ACTIVE_WINDOW from the EWMH spec."]
    #[doc = ""]
    #[doc = " @param window the window to wait on"]
    #[doc = " @param active If 1, wait for active. If 0, wait for inactive."]
    pub fn xdo_wait_for_window_active(
        xdo: *const xdo_t,
        window: Window,
        active: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Map a window. This mostly means to make the window visible if it is"]
    #[doc = " not currently mapped."]
    #[doc = ""]
    #[doc = " @param wid the window to map."]
    pub fn xdo_map_window(xdo: *const xdo_t, wid: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unmap a window"]
    #[doc = ""]
    #[doc = " @param wid the window to unmap"]
    pub fn xdo_unmap_window(xdo: *const xdo_t, wid: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Minimize a window."]
    pub fn xdo_minimize_window(xdo: *const xdo_t, wid: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change window state"]
    #[doc = " @param action the _NET_WM_STATE action"]
    pub fn xdo_window_state(
        xdo: *mut xdo_t,
        window: Window,
        action: ::std::os::raw::c_ulong,
        property: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reparents a window"]
    #[doc = ""]
    #[doc = " @param wid_source the window to reparent"]
    #[doc = " @param wid_target the new parent window"]
    pub fn xdo_reparent_window(
        xdo: *const xdo_t,
        wid_source: Window,
        wid_target: Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a window's location."]
    #[doc = ""]
    #[doc = " @param wid the window to query"]
    #[doc = " @param x_ret pointer to int where the X location is stored. If NULL, X is"]
    #[doc = "   ignored."]
    #[doc = " @param y_ret pointer to int where the Y location is stored. If NULL, X is"]
    #[doc = "   ignored."]
    #[doc = " @param screen_ret Pointer to Screen* where the Screen* the window on is"]
    #[doc = "   stored. If NULL, this parameter is ignored."]
    pub fn xdo_get_window_location(
        xdo: *const xdo_t,
        wid: Window,
        x_ret: *mut ::std::os::raw::c_int,
        y_ret: *mut ::std::os::raw::c_int,
        screen_ret: *mut *mut Screen,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a window's size."]
    #[doc = ""]
    #[doc = " @param wid the window to query"]
    #[doc = " @param width_ret pointer to unsigned int where the width is stored."]
    #[doc = " @param height_ret pointer to unsigned int where the height is stored."]
    pub fn xdo_get_window_size(
        xdo: *const xdo_t,
        wid: Window,
        width_ret: *mut ::std::os::raw::c_uint,
        height_ret: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the currently-active window."]
    #[doc = " Requires your window manager to support this."]
    #[doc = " Uses _NET_ACTIVE_WINDOW from the EWMH spec."]
    #[doc = ""]
    #[doc = " @param window_ret Pointer to Window where the active window is stored."]
    pub fn xdo_get_active_window(
        xdo: *const xdo_t,
        window_ret: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a window ID by clicking on it. This function blocks until a selection"]
    #[doc = " is made."]
    #[doc = ""]
    #[doc = " @param window_ret Pointer to Window where the selected window is stored."]
    pub fn xdo_select_window_with_click(
        xdo: *const xdo_t,
        window_ret: *mut Window,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of desktops."]
    #[doc = " Uses _NET_NUMBER_OF_DESKTOPS of the EWMH spec."]
    #[doc = ""]
    #[doc = " @param ndesktops the new number of desktops to set."]
    pub fn xdo_set_number_of_desktops(
        xdo: *const xdo_t,
        ndesktops: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current number of desktops."]
    #[doc = " Uses _NET_NUMBER_OF_DESKTOPS of the EWMH spec."]
    #[doc = ""]
    #[doc = " @param ndesktops pointer to long where the current number of desktops is"]
    #[doc = "   stored"]
    pub fn xdo_get_number_of_desktops(
        xdo: *const xdo_t,
        ndesktops: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Switch to another desktop."]
    #[doc = " Uses _NET_CURRENT_DESKTOP of the EWMH spec."]
    #[doc = ""]
    #[doc = " @param desktop The desktop number to switch to."]
    pub fn xdo_set_current_desktop(
        xdo: *const xdo_t,
        desktop: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current desktop."]
    #[doc = " Uses _NET_CURRENT_DESKTOP of the EWMH spec."]
    #[doc = ""]
    #[doc = " @param desktop pointer to long where the current desktop number is stored."]
    pub fn xdo_get_current_desktop(
        xdo: *const xdo_t,
        desktop: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move a window to another desktop"]
    #[doc = " Uses _NET_WM_DESKTOP of the EWMH spec."]
    #[doc = ""]
    #[doc = " @param wid the window to move"]
    #[doc = " @param desktop the desktop destination for the window"]
    pub fn xdo_set_desktop_for_window(
        xdo: *const xdo_t,
        wid: Window,
        desktop: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the desktop a window is on."]
    #[doc = " Uses _NET_WM_DESKTOP of the EWMH spec."]
    #[doc = ""]
    #[doc = " If your desktop does not support _NET_WM_DESKTOP, then '*desktop' remains"]
    #[doc = " unmodified."]
    #[doc = ""]
    #[doc = " @param wid the window to query"]
    #[doc = " @param deskto pointer to long where the desktop of the window is stored"]
    pub fn xdo_get_desktop_for_window(
        xdo: *const xdo_t,
        wid: Window,
        desktop: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for windows."]
    #[doc = ""]
    #[doc = " @param search the search query."]
    #[doc = " @param windowlist_ret the list of matching windows to return"]
    #[doc = " @param nwindows_ret the number of windows (length of windowlist_ret)"]
    #[doc = " @see xdo_search_t"]
    pub fn xdo_search_windows(
        xdo: *const xdo_t,
        search: *const xdo_search_t,
        windowlist_ret: *mut *mut Window,
        nwindows_ret: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generic property fetch."]
    #[doc = ""]
    #[doc = " @param window the window to query"]
    #[doc = " @param atom the Atom to request"]
    #[doc = " @param nitems the number of items"]
    #[doc = " @param type the type of the return"]
    #[doc = " @param size the size of the type"]
    #[doc = " @return data consisting of 'nitems' items of size 'size' and type 'type'"]
    #[doc = "   will need to be cast to the type before using."]
    pub fn xdo_get_window_property_by_atom(
        xdo: *const xdo_t,
        window: Window,
        atom: Atom,
        nitems: *mut ::std::os::raw::c_long,
        type_: *mut Atom,
        size: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " Get property of window by name of atom."]
    #[doc = ""]
    #[doc = " @param window the window to query"]
    #[doc = " @param property the name of the atom"]
    #[doc = " @param nitems the number of items"]
    #[doc = " @param type the type of the return"]
    #[doc = " @param size the size of the type"]
    #[doc = " @return data consisting of 'nitems' items of size 'size' and type 'type'"]
    #[doc = "   will need to be cast to the type before using."]
    pub fn xdo_get_window_property(
        xdo: *const xdo_t,
        window: Window,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_uchar,
        nitems: *mut ::std::os::raw::c_long,
        type_: *mut Atom,
        size: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current input state. This is a mask value containing any of the"]
    #[doc = " following: ShiftMask, LockMask, ControlMask, Mod1Mask, Mod2Mask, Mod3Mask,"]
    #[doc = " Mod4Mask, or Mod5Mask."]
    #[doc = ""]
    #[doc = " @return the input mask"]
    pub fn xdo_get_input_state(xdo: *const xdo_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " If you need the symbol map, use this method."]
    #[doc = ""]
    #[doc = " The symbol map is an array of string pairs mapping common tokens to X Keysym"]
    #[doc = " strings, such as \"alt\" to \"Alt_L\""]
    #[doc = ""]
    #[doc = " @returns array of strings."]
    pub fn xdo_get_symbol_map() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a list of active keys. Uses XQueryKeymap."]
    #[doc = ""]
    #[doc = " @param keys Pointer to the array of charcodemap_t that will be allocated"]
    #[doc = "    by this function."]
    #[doc = " @param nkeys Pointer to integer where the number of keys will be stored."]
    pub fn xdo_get_active_modifiers(
        xdo: *const xdo_t,
        keys: *mut *mut charcodemap_t,
        nkeys: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send any events necessary to clear the active modifiers."]
    #[doc = " For example, if you are holding 'alt' when xdo_get_active_modifiers is"]
    #[doc = " called, then this method will send a key-up for 'alt'"]
    pub fn xdo_clear_active_modifiers(
        xdo: *const xdo_t,
        window: Window,
        active_mods: *mut charcodemap_t,
        active_mods_n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send any events necessary to make these modifiers active."]
    #[doc = " This is useful if you just cleared the active modifiers and then wish"]
    #[doc = " to restore them after."]
    pub fn xdo_set_active_modifiers(
        xdo: *const xdo_t,
        window: Window,
        active_mods: *mut charcodemap_t,
        active_mods_n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the position of the current viewport."]
    #[doc = ""]
    #[doc = " This is only relevant if your window manager supports"]
    #[doc = " _NET_DESKTOP_VIEWPORT"]
    pub fn xdo_get_desktop_viewport(
        xdo: *const xdo_t,
        x_ret: *mut ::std::os::raw::c_int,
        y_ret: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the position of the current viewport."]
    #[doc = ""]
    #[doc = " This is only relevant if your window manager supports"]
    #[doc = " _NET_DESKTOP_VIEWPORT"]
    pub fn xdo_set_desktop_viewport(
        xdo: *const xdo_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Kill a window and the client owning it."]
    #[doc = ""]
    pub fn xdo_kill_window(xdo: *const xdo_t, window: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a window without trying to kill the client."]
    #[doc = ""]
    pub fn xdo_close_window(xdo: *const xdo_t, window: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request that a window close, gracefully."]
    #[doc = ""]
    pub fn xdo_quit_window(xdo: *const xdo_t, window: Window) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a client window (child) in a given window. Useful if you get the"]
    #[doc = " window manager's decorator window rather than the client window."]
    pub fn xdo_find_window_client(
        xdo: *const xdo_t,
        window: Window,
        window_ret: *mut Window,
        direction: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a window's name, if any."]
    #[doc = ""]
    #[doc = " @param window window to get the name of."]
    #[doc = " @param name_ret character pointer pointer where the address of the window name will be stored."]
    #[doc = " @param name_len_ret integer pointer where the length of the window name will be stored."]
    #[doc = " @param name_type integer pointer where the type (atom) of the window name will be stored."]
    pub fn xdo_get_window_name(
        xdo: *const xdo_t,
        window: Window,
        name_ret: *mut *mut ::std::os::raw::c_uchar,
        name_len_ret: *mut ::std::os::raw::c_int,
        name_type: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable an xdo feature."]
    #[doc = ""]
    #[doc = " This function is mainly used by libxdo itself, however, you may find it useful"]
    #[doc = " in your own applications."]
    #[doc = ""]
    #[doc = " @see XDO_FEATURES"]
    pub fn xdo_disable_feature(xdo: *mut xdo_t, feature: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Enable an xdo feature."]
    #[doc = ""]
    #[doc = " This function is mainly used by libxdo itself, however, you may find it useful"]
    #[doc = " in your own applications."]
    #[doc = ""]
    #[doc = " @see XDO_FEATURES"]
    pub fn xdo_enable_feature(xdo: *mut xdo_t, feature: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Check if a feature is enabled."]
    #[doc = ""]
    #[doc = " This function is mainly used by libxdo itself, however, you may find it useful"]
    #[doc = " in your own applications."]
    #[doc = ""]
    #[doc = " @see XDO_FEATURES"]
    pub fn xdo_has_feature(
        xdo: *mut xdo_t,
        feature: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the viewport (your display) dimensions"]
    #[doc = ""]
    #[doc = " If Xinerama is active and supported, that api internally is used."]
    #[doc = " If Xineram is disabled, we will report the root window's dimensions"]
    #[doc = " for the given screen."]
    pub fn xdo_get_viewport_dimensions(
        xdo: *mut xdo_t,
        width: *mut ::std::os::raw::c_uint,
        height: *mut ::std::os::raw::c_uint,
        screen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the classname of a given Window."]
    pub fn xdo_get_window_classname(
        xdo: *const xdo_t,
        window: Window,
        name_ret: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
